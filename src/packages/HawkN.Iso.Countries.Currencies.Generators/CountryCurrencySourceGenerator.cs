using System.Reflection;
using System.Text;
using HawkN.Iso.Countries.Currencies.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
namespace HawkN.Iso.Countries.Currencies.Generators;

[Generator]
public class CountryCurrencySourceGenerator : BaseIncrementalGenerator
{
    protected override string HintName => "CountryCurrencyMap.g.cs";

    private const string StubSource = """
                                      // <auto-generated>
                                      //     This file was generated by HawkN.Iso.Currencies.Generators source generator.
                                      //     Do not modify this file manually.
                                      // </auto-generated>
                                      #nullable enable
                                      using System.Collections.Generic;
                                      using System.Collections.Immutable;
                                      using HawkN.Iso.Countries.Models;
                                      using HawkN.Iso.Currencies.Models;
                                      using HawkN.Iso.Countries.Currencies.Models;
                                      namespace HawkN.Iso.Countries.Currencies
                                      {
                                          /// <summary>
                                          /// Provides fast ISO 3166 → ISO 4217 country-to-currency mapping.
                                          /// Generated from Unicode CLDR supplemental data.
                                          /// </summary>
                                          internal static class CountryCurrencyMap
                                          {
                                              /// <summary>
                                              /// Raw string-based data generated from CLDR.
                                              /// Parsed and validated at type initialization.
                                              /// </summary>
                                              internal static readonly ImmutableArray<CountryCurrencyInfoRow> RawData =
                                                  ImmutableArray.Create(
                                                      new CountryCurrencyInfoRow[]
                                                      {
                                                      });
                                          }
                                      }
                                      """;

    private const string MethodsSource = """
                                               private static readonly ImmutableArray<CountryCurrencyInfo> Data;
                                               private static readonly Dictionary<CountryCode.TwoLetterCode, CountryCurrencyInfo> Index;

                                               /// <summary>
                                               /// Attempts to get currency information for a country.
                                               /// </summary>
                                               public static bool TryGet(CountryCode.TwoLetterCode country,out CountryCurrencyInfo? info) => Index.TryGetValue(country, out info);

                                               static CountryCurrencyMap()
                                               {
                                                  var dataBuilder = ImmutableArray.CreateBuilder<CountryCurrencyInfo>(RawData.Length);
                                                  var index = new Dictionary<CountryCode.TwoLetterCode, CountryCurrencyInfo>(RawData.Length);

                                                  foreach (var row in RawData)
                                                  {
                                                     if (!Enum.TryParse(row.CountryCode, out CountryCode.TwoLetterCode country))
                                                        continue;
                                                     if (!Enum.TryParse(row.PrimaryCurrency, out CurrencyCode primary))
                                                        continue;

                                                     var info = new CountryCurrencyInfo
                                                     {
                                                        CountryCode = country,
                                                        PrimaryCurrency = primary,
                                                        SecondaryCurrencies = FilterSecondary(row.SecondaryCurrencies)
                                                     };

                                                     dataBuilder.Add(info);
                                                     index[country] = info;
                                                  }

                                                  Data = dataBuilder.ToImmutable();
                                                  Index = index;
                                               }

                                               private static IReadOnlyList<CurrencyCode> FilterSecondary(IReadOnlyList<string> values)
                                               {
                                                  if (values.Count == 0)
                                                     return Array.Empty<CurrencyCode>();

                                                  var buffer = new CurrencyCode[values.Count];
                                                  var count = 0;

                                                  foreach (var value in values)
                                                  {
                                                     if (Enum.TryParse(value, out CurrencyCode code))
                                                        buffer[count++] = code;
                                                  }

                                                  if (count == 0)
                                                     return Array.Empty<CurrencyCode>();

                                                  if (count == buffer.Length)
                                                     return buffer;

                                                  var result = new CurrencyCode[count];
                                                  Array.Copy(buffer, result, count);
                                                  return result;
                                               }
                                         """;

    public override void Initialize(IncrementalGeneratorInitializationContext context)
    {
        ErrorFactory.Clear();
        var jsonProvider = context.CompilationProvider.Select(ReadDataResource);
        context.RegisterSourceOutput(jsonProvider, (spc, tuple) => GenerateSourceOutput(tuple, spc));
    }

    static (string, string) ReadDataResource(Compilation compilation, CancellationToken ct)
    {
        try
        {
            return LoadResources(Assembly.GetExecutingAssembly());
        }
        catch (InvalidOperationException ex)
        {
            var errorMsg = $"{Constants.ErrorMark}:{ex.Message}";
            return (errorMsg, errorMsg);
        }
    }

    private void GenerateSourceOutput((string originalXml, string translationsXml) tuple,
        SourceProductionContext spc)
    {
        try
        {
            if (HasResourceErrors(tuple, out var errorMessages))
            {
                foreach (var msg in errorMessages)
                    ReportResourceError(msg);

                AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
                return;
            }



            var loader = new CurrencyDataLoader(tuple.originalXml, tuple.translationsXml);
            var sb = CreateSourceBuilder(
                Constants.GeneratorName,
                Constants.DefaultNamespace,
                Constants.ExtendedSourceData,
                Constants.SystemNamespaces
                    .Concat(Constants.ReferencesNamespaces)
                    .ToArray());

            sb.AppendLine("   /// <summary>")
                .AppendLine("   /// Provides fast ISO 3166 → ISO 4217 country-to-currency mapping.")
                .AppendLine("   /// Generated from Unicode CLDR supplemental data.")
                .AppendLine("   /// </summary>")
                .AppendLine("   internal static class CountryCurrencyMap")
                .AppendLine("   {");

            var list = new List<GeneratedCountryCurrencyRow>();
            foreach (var group in GroupByCountry(loader.ActualCurrencyData))
            {
                var current = group.Value.Where(c => c.IsCurrent).ToList();
                if (current.Count == 0)
                    continue;
                var primary = current[0].CurrencyCode;
                var secondary = new List<string>();
                for (var i = 1; i < current.Count; i++)
                {
                    var code = current[i].CurrencyCode;
                    if (!secondary.Contains(code))
                        secondary.Add(code);
                }

                list.Add(new GeneratedCountryCurrencyRow(
                    group.Key,
                    primary,
                    secondary));
            }

            GenerateDataSection(sb, "RawData", list);

            sb.AppendLine(MethodsSource);

            sb.AppendLine("    }").AppendLine("}");

            if (ErrorFactory.IsExists())
            {
                AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
                return;
            }
            spc.AddSource(HintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }
        catch (OperationCanceledException)
        {
            // Let the host (Roslyn) handle cancellations properly.
            throw;
        }
        catch (Exception ex)
        {
            ErrorFactory.Create(new ErrorDescription
            {
                DiagnosticDescriptor = new DiagnosticDescriptor(
                    CreateDescriptorId("0"),
                    Constants.DiagnosticsTitle,
                    $"Unexpected exception: {ex.Message}. Stacktrace: {ex.StackTrace}",
                    string.Empty,
                    DiagnosticSeverity.Error,
                    true),
                GeneratorType = GeneratorType.Database
            });
            AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
        }
    }

    private static bool HasResourceErrors((string originalXml, string translationsXml) tuple,
        out List<string> messages)
    {
        messages = [];
        if (tuple.originalXml.StartsWith(Constants.ErrorMark)) messages.Add("original:" + tuple.originalXml);
        if (tuple.translationsXml.StartsWith(Constants.ErrorMark)) messages.Add("translations:" + tuple.translationsXml);
        return messages.Count > 0;
    }

    private static void GenerateDataSection(StringBuilder sb, string propertyName, IReadOnlyList<GeneratedCountryCurrencyRow> data)
    {
        sb.AppendLine("      /// <summary>")
            .AppendLine("      /// Raw string-based data generated from CLDR.")
            .AppendLine("      /// Parsed and validated at type initialization.")
            .AppendLine("      /// </summary>");
        sb.AppendLine(
                $"      internal static ImmutableArray<CountryCurrencyInfoRow> {propertyName} = ImmutableArray.Create(new CountryCurrencyInfoRow[]")
            .AppendLine("         {");
        foreach (var item in data)
        {
            sb.AppendLine("               new CountryCurrencyInfoRow()");
            sb.AppendLine("               {");
            sb.AppendLine($"                    CountryCode = \"{item.CountryCode}\",");
            sb.AppendLine($"                    PrimaryCurrency = \"{item.PrimaryCurrency}\",");
            if (item.SecondaryCurrencies.Count == 0)
            {
                sb.AppendLine("                    SecondaryCurrencies = []");
            }
            else
            {
                sb.AppendLine("                    SecondaryCurrencies = new []");
                sb.AppendLine("                    {");
                foreach (var c in item.SecondaryCurrencies)
                    sb.AppendLine("                        \"" + c + "\",");
                sb.AppendLine("                    }");
            }
            sb.AppendLine("               },");
        }
        sb.AppendLine("         });");
    }

    private static Dictionary<string, List<ParsedCurrencyRow>> GroupByCountry(
        IReadOnlyList<ParsedCurrencyRow> parsed)
    {
        var dict = new Dictionary<string, List<ParsedCurrencyRow>>();
        foreach (var p in parsed)
        {
            if (!dict.TryGetValue(p.CountryCode, out var list))
            {
                list = [];
                dict[p.CountryCode] = list;
            }
            list.Add(p);
        }
        return dict;
    }

    private void ReportResourceError(string msg)
    {
        var parts = msg.Split([':'], 2);
        var name = parts[0];
        var text = parts.Length > 1 ? parts[1] : "Unknown error";

        ErrorFactory.Create(new ErrorDescription
        {
            DiagnosticDescriptor = new DiagnosticDescriptor(
                CreateDescriptorId("1"),
                Constants.DiagnosticsTitle,
                $"Failed to load {name} resource: {text}",
                string.Empty,
                DiagnosticSeverity.Error,
                true),
            GeneratorType = GeneratorType.Database
        });
    }
}